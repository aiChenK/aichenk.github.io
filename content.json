{"pages":[],"posts":[{"title":"Hexo Test","text":"Hexo 测试","link":"/2019/01/2019/Test/"},{"title":"tp6动态连接数据库","text":"使用场景tp6连接除database.php配置外的数据库（临时数据库等） 使用方式123456789101112131415//use think\\facade\\Config;$config = Config::get('database');$config['connections']['tmp'] = [ 'type' =&gt; 'mysql', 'hostname' =&gt; 'localhost', 'database' =&gt; 'test', 'username' =&gt; 'root', 'password' =&gt; 'root', 'hostport' =&gt; 3306, 'params' =&gt; [], 'charset' =&gt; 'utf8mb4'];Config::set($config, 'database');Db::connect('tmp')-&gt;query('select * from t limit 1');","link":"/2021/09/2021/tp6%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"rabbitmq-channel断网后没有断开情况记录","text":"现象队列中一直有unacked数据 复现监听队列，使用不自动应答模式，拿到消息不应答，断开网络，关闭进程rabbitmq中channel一直存在，state为idle状态只能强制手动关闭连接 疑问 rabbitmq对于tcp连接断开的心跳时间？ 默认30分钟，根据rabbitmq.conf中consumer_timeout确定 如何处理网络异常断开的unacked消息？ 等待连接超时，或强制断开channel 解答来源：Consumers — RabbitMQ If a consumer does not ack its delivery for more than the timeout value (30 minutes by default), its channel will be closed with a PRECONDITION_FAILED channel exception. The error will be logged by the node that the consumer was connected to.The timeout value is configurable in [rabbitmq.conf] (in milliseconds): 12# 30 minutes in millisecondsconsumer_timeout = 1800000","link":"/2021/09/2021/rabbitmq-channel%E6%96%AD%E7%BD%91%E5%90%8E%E6%B2%A1%E6%9C%89%E6%96%AD%E5%BC%80%E6%83%85%E5%86%B5%E8%AE%B0%E5%BD%95/"},{"title":"Hexo-Anatolo主题添加gitalk评论系统","text":"一开始准备使用gitment作为评论系统，但是搭完发现已经不可用，随后找到了差不多的gitalkgitalk已经有很多主题集成，但是很遗憾我使用的Anatolo还没有，尝试了下还算简单，现在把大概步骤写一下 相关地址Anatolo主题：https://github.com/Ben02/hexo-theme-Anatolegitalk评论：https://github.com/gitalk/gitalkmd5：https://github.com/blueimp/JavaScript-MD5 （issue label name 不允许超过50字符，所以使用md5生成id） 使用准备工作选择一个公共github存储库（已存在或创建一个新的github存储库）用于存储评论创建GitHub Application，Authorization callback URL填写博客地址（点此申请）生成Client Id及Client Secret，复制保留 主题更改定位到Anatolo主题文件夹内，打开{Anatolo Path}/layout/partial/comments.pug文件最下方添加此段代码 123456789101112131415161718if theme.gitalk if theme.gitalk.enable == true a#comments #vcomments(style=&quot;margin:0 30px;&quot;) link(rel='stylesheet' href='https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css') script(src='https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js') script(src='https://cdn.jsdelivr.net/npm/blueimp-md5@2.19.0/js/md5.min.js') script. var gitalk = new Gitalk({ clientID: '#{theme.gitalk.client_id}', clientSecret: '#{theme.gitalk.client_secret}', owner: '#{theme.gitalk.owner}', repo: '#{theme.gitalk.repo}', admin: ['#{theme.gitalk.admin}'], id: md5(location.pathname), // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode }) gitalk.render('vcomments') 添加配置在主题文件夹下_config.yml或根目录下_config.anatolo.yml添加gitalk配置 1234567gitalk: enable: true owner: #owner repo: #repo name admin: #admin name client_id: #client_id client_secret: #client_secret 效果","link":"/2022/02/2022/Hexo-Anatolo%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"title":"k8s下php定时任务接入阿里云SchedulerX","text":"背景php上阿里云ack（k8s）后，想保留原来定时任务，但是又需要保持单点运行，所以考虑使用阿里云SchedulerX来方便管理。官方文档如下：虽然官方文档显示可以用Sidecar方式接入，但是实际并非进入到目标容器执行，仅能执行http请求到目标容器。 实现使用agent方式接入，直接打包入php镜像，缺点就是需要java运行环境，镜像会很大并且占用运行内存。建议有定时任务需求才使用此镜像。链接地址：https://help.aliyun.com/document_detail/149969.html然后在Deployment配置文件上增加env 12345678910111213# spec &gt; template &gt; spec &gt; containers - name: php-fpm env: - name: &quot;SCHEDULERX_ENDPOINT&quot; value: &quot;${SCHEDULERX_ENDPOINT}&quot; - name: &quot;SCHEDULERX_NAMESPACE&quot; value: &quot;${SCHEDULERX_NAMESPACE}&quot; - name: &quot;SCHEDULERX_GROUPID&quot; value: &quot;${SCHEDULERX_GROUPID}&quot; - name: &quot;SCHEDULERX_APPKEY&quot; value: &quot;${SCHEDULERX_APPKEY}&quot; - name: &quot;SCHEDULERX_STARTER_MODE&quot; value: &quot;sidecar&quot; 部分dockerfilephp5.6-fpm1234567891011FROM php:5.6-fpm# SchedulerX AgentRUN mkdir -p /usr/share/man/man1 \\ &amp;&amp; apt-get install -y openjdk-8-jdk wget \\ &amp;&amp; cd /opt \\ &amp;&amp; wget https://schedulerx2.oss-cn-hangzhou.aliyuncs.com/agent/schedulerxAgent-1.4.2.tar.gz \\ &amp;&amp; tar -xf schedulerxAgent-1.4.2.tar.gz \\ &amp;&amp; rm schedulerxAgent-1.4.2.tar.gz \\ &amp;&amp; mkdir -p /root/logs/schedulerx \\ &amp;&amp; sed -i '45c \\ \\ \\ \\ \\ \\ \\ \\ sed -i &quot;4c appKey=${SCHEDULERX_APPKEY}&quot; ${WORKER_CONF_DIR}/agent.properties' /opt/schedulerxAgent/bin/start-200m.sh php7.4-fpm12345678910FROM php7.4-fpm# SchedulerX AgentRUN apt-get install -y openjdk-11-jdk wget \\ &amp;&amp; cd /opt \\ &amp;&amp; wget https://schedulerx2.oss-cn-hangzhou.aliyuncs.com/agent/schedulerxAgent-1.4.2.tar.gz \\ &amp;&amp; tar -xf schedulerxAgent-1.4.2.tar.gz \\ &amp;&amp; rm schedulerxAgent-1.4.2.tar.gz \\ &amp;&amp; mkdir -p /root/logs/schedulerx \\ &amp;&amp; sed -i '45c \\ \\ \\ \\ \\ \\ \\ \\ sed -i &quot;4c appKey=${SCHEDULERX_APPKEY}&quot; ${WORKER_CONF_DIR}/agent.properties' /opt/schedulerxAgent/bin/start-200m.sh","link":"/2022/05/2022/k8s%E4%B8%8Bphp%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%8E%A5%E5%85%A5%E9%98%BF%E9%87%8C%E4%BA%91SchedulerX/"},{"title":"PHP性能分析之xdebug+webgrind","text":"Xdebug是一个开放源代码的PHP程序调试器，可以用来跟踪，调试和分析PHP程序的运行状况。这里仅说明用来对php运行状态的使用说明。 xdebug安装 运行php -m查看是否已安装xdebug扩展，已安装则跳过当前步骤 源码地址：https://github.com/xdebug/xdebug 编译完成后编辑php.ini文件，添加如下 12345678910111213; 引入xdebug扩展extension=xdebug.so; 配置xdebug[xdebug]; 自动生产分析文件xdebug.profiler_enable=0; 启用触发，url添加参数XDEBUG_PROFILE才会生成分析文件xdebug.profiler_enable_trigger=1; 分析文件储存路径(默认/tmp); xdebug.profiler_output_dir = &quot;/tmp/xdebug&quot;; 分析文件名称; xdebug.profiler_output_name=cachegrind.out.%p 重启php-fpm或apache以生效 webgrind安装 webgrind只需引入即可 源码地址：https://github.com/jokkedk/webgrind/ 配置nginx或放入项目中 使用 请求接口，添加参数XDEBUG_PROFILE，会在指定路径中生成一个文件 打开webgrind 选好参数后点击update如下图 参数说明 show 90%：要显示耗时比率，最好不要选100%，会卡。相当于显示出比较耗时的方法 Invocation Count：被调用执行的次数 Total Self Cost：自身耗时 Total Inclusive Cost：综合耗时 比例条：蓝色(内置函数)，灰色(引入文件)，青色(自定义函数)，橙色(过程执行所占时间的比例)","link":"/2019/03/2019/PHP%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Bxdebug+webgrind/"},{"title":"mac pecl安装swoole失败：fatal error: 'openssl/ssl.h' file not found","text":"mac下使用brew安装arm版php7.2，pecl命令安装swoole命令：pecl install swoole发生如下报错 1234567891011121314/private/tmp/pear/temp/swoole/ext-src/php_swoole_private.h:84:2: error: &quot;Enable openssl support, require openssl library&quot;#error &quot;Enable openssl support, require openssl library&quot; ^In file included from /private/tmp/pear/temp/swoole/ext-src/php_swoole.cc:16:In file included from /private/tmp/pear/temp/swoole/ext-src/php_swoole_cxx.h:20:In file included from /private/tmp/pear/temp/swoole/ext-src/php_swoole_coroutine.h:22:In file included from /private/tmp/pear/temp/swoole/include/swoole_coroutine.h:22:In file included from /private/tmp/pear/temp/swoole/include/swoole_socket.h:33:/private/tmp/pear/temp/swoole/include/swoole_ssl.h:27:10: fatal error: 'openssl/ssl.h' file not found#include &lt;openssl/ssl.h&gt; ^~~~~~~~~~~~~~~2 errors generated.make: *** [ext-src/php_swoole.lo] Error 1ERROR: `make' failed openssl本机已安装，所以只需要提示是否启用openssl指定路径即可（以下路径为brew安装openssl路径） 123456➜ ~ pecl install swoole...enable sockets supports? [no] : yesenable openssl support? [no] : yes --with-openssl-dir=/opt/homebrew/opt/openssl...","link":"/2021/09/2021/mac%20pecl%E5%AE%89%E8%A3%85swoole%E5%A4%B1%E8%B4%A5/"},{"title":"php getenv无法获取环境变量","text":"现象php在nginx+fpm模式下getenv()方法获取到的内容与cli模式下不同 举例 shell下输出HOSTNAME 12➜ ~ echo $HOSTNAMEphp-nginx nginx+fpm无法获取HOSTNAME环境变量 123➜ ~ cat test.php&lt;?phpvar_dump(getenv(&quot;HOSTNAME&quot;)); php cli模式下输出 12➜ ~ php -r 'echo getenv(&quot;HOSTNAME&quot;), PHP_EOL;'php-nginx 原因nginx+fpm下环境变量通过nginx的fastcgi传递，所有环境变量需要在nginx配置文件下的fastcgi_params文件指定 解决增加fastcgi_params参数，并重启nginx 123echo &quot;fastcgi_param HOSTNAME php-nginx;&quot; &gt;&gt; /etc/nginx/fastcgi_paramsnginx -s reload","link":"/2021/12/2021/php-getenv%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"php阿里云oss-sdk上传失败情况处理","text":"现象oss上传没有成功，但是拿到了地址，导致访问时返回404状态码 思路我们先看自己写的上传oss部分代码 123456public function oss(string $file, string $object){ $ossClient = new OssClient($this-&gt;config['accessKeyId'], $this-&gt;config['accessKeySecret'], $this-&gt;config['endpoint']); $result = $ossClient-&gt;uploadFile($this-&gt;config['bucket'], ltrim($object, '/'), $file); return $result['oss-request-url'];} 按理说是由sdk返回的result中拿到的地址，上传失败应该会直接抛出异常再看其中uploadFile代码部分 1234567public function uploadFile($bucket, $object, $file, $options = NULL){ // ...省略代码 $response = $this-&gt;auth($options); $result = new PutSetDeleteResult($response); return $result-&gt;getData();} 其中主要方法是$this-&gt;auth($options)，再进去看 123456789101112131415161718192021222324252627282930private function auth($options){ // ...省略代码 try { $request-&gt;send_request(); } catch (RequestCore_Exception $e) { throw(new OssException('RequestCoreException: ' . $e-&gt;getMessage())); } $response_header = $request-&gt;get_response_header(); $response_header['oss-request-url'] = $requestUrl; $response_header['oss-redirects'] = $this-&gt;redirects; $response_header['oss-stringtosign'] = $string_to_sign; $response_header['oss-requestheaders'] = $request-&gt;request_headers; $data = new ResponseCore($response_header, $request-&gt;get_response_body(), $request-&gt;get_response_code()); //retry if OSS Internal Error if ((integer)$request-&gt;get_response_code() === 500) { if ($this-&gt;redirects &lt;= $this-&gt;maxRetries) { //Sets the sleep time betwen each retry. $delay = (integer)(pow(4, $this-&gt;redirects) * 100000); usleep($delay); $this-&gt;redirects++; $data = $this-&gt;auth($options); } } $this-&gt;redirects = 0; return $data;} 可以看到抛异常情况只在send_request方法，而里面只在curl本身无法请求（比如host无法解析）才会抛出RequestCore_Exception异常也就是说如果是业务类的错误是会正常走下去的虽然response_code为500时会有重试，但是在这之前已经创建了response对象如果非500错误，或者超过重试次数都会返回这个对象，最终情况就是不管怎么样都会返回result结构体 解决在拿到result结构体后先进行response_code判断，代码如下 123456789public function oss(string $file, string $object){ $ossClient = new OssClient($this-&gt;config['accessKeyId'], $this-&gt;config['accessKeySecret'], $this-&gt;config['endpoint']); $result = $ossClient-&gt;uploadFile($this-&gt;config['bucket'], ltrim($object, '/'), $file); if ($result['info']['http_code'] !== 200) { throw new OssException('上传失败'); } return $result['oss-request-url'];} 补充查阅了官方示例也没有对这些情况进行处理，示例如下：地址：https://help.aliyun.com/document_detail/88473.html 1234567891011// ...省略代码try{ $ossClient = new OssClient($accessKeyId, $accessKeySecret, $endpoint); $ossClient-&gt;uploadFile($bucket, $object, $filePath);} catch(OssException $e) { printf(__FUNCTION__ . &quot;: FAILED\\n&quot;); printf($e-&gt;getMessage() . &quot;\\n&quot;); return;}print(__FUNCTION__ . &quot;OK&quot; . &quot;\\n&quot;); 附上文档中其他错误码说明，文档链接：https://help.aliyun.com/document_detail/31978.html#section-orz-dlw-bz 错误码 HTTP状态码 描述 MissingContentLength 411 请求头没有采用chunked encoding编码方式，或没有设置Content-Length参数。 InvalidEncryptionAlgorithmError 400 指定x-oss-server-side-encryption的值无效。取值：AES256、KMS或SM4。 AccessDenied 403 添加Object时，用户对设置的Bucket没有访问权限。 NoSuchBucket 404 添加Object时，设置的Bucket不存在。 InvalidObjectName 400 传入的Object key长度大于1023字节。 InvalidArgument 400 返回该错误的可能原因如下：添加的Object大小超过5 GB。x-oss-storage-class等参数的值无效。 RequestTimeout 400 指定了Content-Length，但没有发送消息体，或者发送的消息体小于指定的大小。此种情况下服务器会一直等待，直至请求超时。 Bad Request 400 在请求中指定Content-MD5后，OSS会计算所发送数据的MD5值，并与请求中Conent-MD5的值进行比较。如果二者不一致，则返回该错误。 KmsServiceNotEnabled 403 将x-oss-server-side-encryption指定为KMS，但没有预先购买KMS套件。 FileAlreadyExists 409 当请求的Header中携带x-oss-forbid-overwrite=true时，表示禁止覆盖同名文件。如果同名文件已存在，则返回该错误。 FileImmutable 409 Bucket中的数据处于被保护状态时，如果尝试删除或修改相应数据，则返回该错误。","link":"/2022/04/2022/php%E9%98%BF%E9%87%8C%E4%BA%91oss-sdk%E4%B8%8A%E4%BC%A0%E5%A4%B1%E8%B4%A5%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86/"},{"title":"处理php使用ZipArchive解压时中文乱码问题","text":"使用php自带的ZipArchive来解压带中文文件名压缩包时会造成乱码，现象如下： 原结构 解压代码1234567$zip = new \\ZipArchive();$res = $zip-&gt;open('./钱学森班.zip');if ($res !== true){ throw new \\Exception('打开压缩包失败');}$zip-&gt;extractTo('./cache');$zip-&gt;close(); 解压后 原因默认windows，mac打压缩包时编码为简体中文，解压时未作文件转化导致解压结果与预期不符 解决方法打开压缩包后先将内部文件名及目录进行转码，转码后需关闭压缩包并重新打开解压 实现如下： 12345678910111213141516171819$zipName = './钱学森班.zip';$zip = new \\ZipArchive();$res = $zip-&gt;open($zipName);if ($res !== true){ throw new \\Exception('打开压缩包失败');}// 加入此段↓$fileNum = $zip-&gt;numFiles;for ($i = 0; $i &lt; $fileNum; $i++) { $statInfo = $zip-&gt;statIndex($i, ZipArchive::FL_ENC_RAW); $zip-&gt;renameIndex($i, iconv('GBK', 'utf-8//IGNORE', $statInfo['name']));}$zip-&gt;close();$zip-&gt;open($zipName);// 截至↑$zip-&gt;extractTo($extractTo);$zip-&gt;close(); 注意事项 转码后因为修改了原压缩包文件，所以不可重复转码，若不想对原文件产生影响需先复制（php-zip扩展是自己读文件流，不需要复制） 转换前使用mb_detect_encoding进行编码判断依然是返回UTF-8","link":"/2020/11/2020/php%E4%BD%BF%E7%94%A8ZipArchive%E8%A7%A3%E5%8E%8B%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"php下载大文件失败的一次坑","text":"说明php提供文件的储存和下载，nginx作为web服务器，fpm做解析。 现象当下载一个5M大小的图片时，总提示下载失败，或下载下来的文件不完整，仅显示部分图像（每次下载不一样） php下载相关代码123456789101112$file = BASE_PATH . '/public/files/IMG_5727.jpg';$size = filesize($file);header( &quot;Content-type: application/octet-stream&quot; );header(&quot;Accept-Ranges: bytes&quot;);header(&quot;Accept-Length: {$size}&quot;);header(&quot;Content-Disposition: attachment; filename=IMG_5727.jpg&quot;);$fp = fopen($file, 'rb');$readBuffer = 4096;while (!feof($fp)) { echo fread($fp, $readBuffer);}fclose($fp); 解决 找了一圈后去服务器上查看了nginx日志，确实有报错信息 1232020/05/06 13:09:13 [crit] 1482#0: *23258 open() &quot;/aichenk/soft/nginx/fastcgi_temp/4/17/0000000174&quot; failed (13: Permission denied) while reading upstream, client: 172.21.0.12, server: 192.168.5.5, request: &quot;GET /temp/t2 HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9001&quot;, host: &quot;192.168.5.5:8080&quot; nginx显示权限问题，最终把nginx运行身份与fpm进行统一 12345678910# fpm配置[www]user = daemongroup = daemon# 查看到fpm运行身份为`daemon`,编辑nginx配置设置身份# nginx配置#user nobody;user daemon; 之前路径归属用户更改 1chown -R daemon /aichenk/soft/nginx/fastcgi_temp/ 测试通过 解释个人分析这次错误其实是数据放到缓冲区才体现，理论上不光是大文件，数据传输量超过一定值也会有这个问题，在搭建环境的时候注意就可以了","link":"/2020/05/2020/php%E4%B8%8B%E8%BD%BD%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%80%E6%AC%A1%E5%9D%91/"},{"title":"tp5.0升级tp6.0遇到的问题处理（部分）","text":"概述 tp5.0 -&gt; tp5.1 -&gt; tp6.0 都有较大改动，虽然有官方的升级指导文件但是也没有覆盖所有情况 本次升级的过程也是作为一次尝试，以下问题仅是本人在升级项目中遇到，未包括所有情况 如果不是必要情况，强烈不推荐升级 遇到的问题 路由参数绑定不再支持按照名称成对解析（url_param_type） 本项可直接查看此链接 model不再支持get()/all()方法 可以使用find()/select()来作为替换 若遇到get()参数使用的不是主键，则需配合where()-&gt;find()使用 系统库think\\Db | think\\Session等需要使用门面 如think\\facade\\Session等，具体可查看此处 model中init()方法的模型事件self::beforeInsert(function ($obj) { })等无法使用 更改为public static function onBeforeInsert($obj) {} 控制器中$this-&gt;redirect('/path'); return true;无法使用 直接更改为return redirect('/path'); Session需设置为中间件使用 ROOT_PATH | TEMP_PATH | DS等全局变量不可使用 可替换为app()-&gt;getRootPath() | app()-&gt;getRuntimePath()等 上传文件validate方法不可用 控制器中可使用$this-&gt;validate()或validate()-&gt;check($file)","link":"/2021/07/2021/tp5.0%E5%8D%87%E7%BA%A7tp6.0%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"title":"处理tp5升级到tp6时，url参数无法按顺序解析(url_param_type)","text":"背景原项目使用tp5多应用模式，未使用强制路由，且url参数是按照顺序解析url_param_type = 1想尝试能不能从tp5升级到tp6，虽然有官方升级文档，但tp6的url参数方式只能按照名称成对解析，无法满足需求，于是看了下源码看看能不能处理 示例tp5原模式 顺序参数模式（config.php文件中设置'url_param_type' =&gt; 1） 文件路径：application/index/controller/TestController.php 12345public function test($a = '', $b = ''){ echo '参数a：', $a, '&lt;br/&gt;'; echo '参数b：', $b, '&lt;br/&gt;';} 执行curl http://localhost/index/test/test/111/222 输出 12参数a：111参数b：222 tp6尝试 同样代码输出 12参数a：222参数b： 推荐方式：curl http://localhost/index/test/test/a/111/b/222 或者其实：curl http://localhost/index/test/test/fff/111/fff/222也行，具体可以打印request()-&gt;param()看看就知道了 分析 从上述结果可以看出只要解决param解析问题即可，tp6不定义路由时都是按照名称成对解析的 找到tp6解析的地方think\\route\\dispatch\\Url-&gt;parseUrl(string $url): array 解决 更改parseUrl方法可以处理，但对框架有影响，所以建议从项目内部替换Url类 可以直接引入我写的包 composer require aichenk/tp6-route-param 在config/route.php中添加参数'url_param_type' =&gt; 1即可（0即为关闭） tp6输出 12参数a：111参数b：222","link":"/2021/07/2021/tp5%E5%8D%87%E7%BA%A7%E5%88%B0tp6%E6%97%B6%EF%BC%8Curl%E5%8F%82%E6%95%B0%E6%97%A0%E6%B3%95%E6%8C%89%E9%A1%BA%E5%BA%8F%E8%A7%A3%E6%9E%90/"},{"title":"tp6路由匹配参数获取问题","text":"tp6是一个封装度很高的框架，在大部分场景下都能做到开箱即用本次遇到情况为，当请求消息体为索引数组时，路由参数无法正常获取 首先看正常路由匹配路由定义 1Route::post('test/:a/:b', 'index/test'); Index控制器输出参数 12345public function test($a, $b){ echo 'a:', $a, PHP_EOL; echo 'b:', $b, PHP_EOL;} 启动服务php think run -p 8080 请求测试，如下我们得到了我们所需要的结果 123➜ ~ curl -X POST http://localhost:8080/test/1/2a:1b:2 将IndexController-&gt;test中$a, $b参数调换位置（路由不变） 12345public function test($b, $a){ echo 'a:', $a, PHP_EOL; echo 'b:', $b, PHP_EOL;} 重新请求，得到的结果依然不变 123➜ ~ curl -X POST http://localhost:8080/test/1/2a:1b:2 那么我们是否可以得到结论：tp6控制器参数会根据路由参数名自动匹配？看以上结果好像是没问题，但是有个大坑！ 请求体正文中加入数组内容路由，控制器输出方法都不变，仅增加requestBody，得到如下结果 123➜ ~ curl -X POST -H &quot;content-type:application/json&quot; -d &quot;[3, 4]&quot; http://localhost:8080/test/1/2a:4b:3 说好的路由匹配呢！ 原因说明在方法中打印出request-&gt;param()可查看到刚才的请求最终得到的参数 123456array:4 [ 0 =&gt; 3 1 =&gt; 4 &quot;a&quot; =&gt; &quot;1&quot; &quot;b&quot; =&gt; &quot;2&quot;] 可以看到消息体中参数是索引数组部分，而路由参数a，b为关联数组部分tp在最终匹配action参数的时候，按照先分配索引，再分配关联的顺序进行了参数传入，导致没有得到我们想要的效果若消息体内增加键值，我们重新尝试，如下依然是我们想要的结果 123➜ ~ curl -X POST -H &quot;content-type:application/json&quot; -d &quot;{\\&quot;a\\&quot;:3}&quot; http://localhost:8080/test/1/2a:1b:2 所以大概得到结论：param()参数的来源为先获取query、body等参数，再覆盖上路由参数 解决方案既然已经知道原因，那么解决方案就比较好处理了 方案1更改消息体，避免直接使用索引数组传递，如 123➜ ~ curl -X POST -H &quot;content-type:application/json&quot; -d &quot;{\\&quot;data\\&quot;:[3, 4]}&quot; http://localhost:8080/test/1/2a:1b:2 我们在方法内根据键值data即可获取想要的数据 方案2不需要更改结构体，但action参数不通过传入参数获取，由内部自己获取 123456789// action代码如下public function test(){ $a = $this-&gt;request-&gt;param('a'); $b = $this-&gt;request-&gt;param('b'); echo 'a:', $a, PHP_EOL; echo 'b:', $b, PHP_EOL; var_dump($this-&gt;request-&gt;param());} 使用原消息体测试 12345678910111213➜ ~ curl -X POST -H &quot;content-type:application/json&quot; -d &quot;[3, 4]&quot; http://localhost:8080/test/1/2a:4b:3array(4) { [0]=&gt; int(3) [1]=&gt; int(4) [&quot;a&quot;]=&gt; string(1) &quot;1&quot; [&quot;b&quot;]=&gt; string(1) &quot;2&quot;} 总结根据结果，不能说这是tp的BUG，可以说这次问题是不熟悉导致，但也算是一个坑吧，在遇到这种情况下确实容易摸不着头脑大家项目内使用时多多注意即可~","link":"/2020/06/2020/tp6%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E9%97%AE%E9%A2%98/"},{"title":"vsftpd配置遇到的错误","text":"环境：centos 7 yum安装yum install -y vsftpd 增加用户1234# 家目录为/www 并设置nologinuseradd -d /www -s /sbin/nologin /www# 修改密码passwd www 配置（/etc/vsftpd/vsftpd.conf)123456789101112131415161718192021anonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022anon_upload_enable=NOdirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESchown_uploads=YESxferlog_file=/var/log/xferlogxferlog_std_format=YESascii_upload_enable=YESascii_download_enable=YESchroot_local_user=YESlisten=YESlisten_ipv6=NOpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YESallow_writeable_chroot=YES 启动服务123systemctl start vsftpd# 设置开机启动systemctl enable vsftpd 遇到错误 - 1 530 Login incorrect. 解决方案编辑文件 /etc/pam.d/vsftpd 123456789#%PAM-1.0Ssession optional pam_keyinit.so force revokeauth required pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed# 注释这行#auth required pam_shells.soauth include password-authaccount include password-authsession required pam_loginuid.sosession include password-auth 遇到错误 - 2 500 OOPS: vsftpd: refusing to run with writable root inside chroot() 解决方案编辑文件 /etc/vsftpd/vsftpd.conf 12# 增加该行allow_writeable_chroot=YES","link":"/2020/03/2020/vsftpd%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/"},{"title":"搭建私有Composer仓库","text":"适用于公司内部进行包管理，在组件化、服务化场景下部分业务代码不方便放到开源平台，可使用内部git服务器，配合composer/satis项目搭建私有composer处理内部依赖，优化代码结构，统一依赖 环境 系统：windows 10 php版本：7.2.17（当前satis要求^7.2.9) git服务：gitlab 示例项目: aichenk/open-crypt 步骤 提交项目源码到gitlab 需配置composer.json，步骤本次不作说明 需可以通过http方式访问（gitlab本身支持） 使用composer建立satis项目并加载依赖 123$ composer create-project composer/satis satis --stability=dev --keep-vcs$ cd satis$ composer install 增加配置文件satis.json（本次建立在项目根目录，可以自由配置） 12345678910111213{ &quot;name&quot;: &quot;satis&quot;, &quot;homepage&quot;: &quot;http://localhost:8080/&quot;, &quot;repositories&quot;: [ { &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://localhost/aichenk/open-crypt.git&quot; } ], &quot;config&quot;: { &quot;secure-http&quot;: false }} homepage表示satis访问地址（web服务器配置，后续用到） repositories中写入git仓库地址 secure-http:false表示支持http访问 生成仓库列表及网页文件 1$ php bin/satis build satis.json ./web 配置web访问（本示例使用php自带web服务演示） 1$ php -S 0.0.0.0:8080 -t ./web 打开配置的homepage验证是否成功 使用 修改项目composer.json文件 1234567891011121314{ &quot;repositories&quot;: { &quot;packagist&quot;: { &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;http://localhost:8080/&quot; } }, &quot;config&quot;: { &quot;secure-http&quot;: false }, &quot;require&quot;: { &quot;aichenk/open-crypt&quot;: &quot;^1.0&quot; }} 执行composer install即可 其他说明 项目中添加多个composer源 123456789101112{ &quot;repositories&quot;: [ { &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;http://localhost:8080&quot; }, { &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://packagist.phpcomposer.com&quot; } ]} 不使用satis直接使用gitlab加载包 123456789101112{ &quot;repositories&quot;: [ { &quot;type&quot;: &quot;vcs&quot;, &quot;url&quot;: &quot;http://localhost/aichenk/open-crypt.git&quot; }, { &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://packagist.phpcomposer.com&quot; } ]}","link":"/2019/12/2019/%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Composer%E4%BB%93%E5%BA%93/"},{"title":"同域名前后端分离项目nginx配置实践","text":"新项目采用前后端分离的方式开发，前后端代码打算分开部署（同机器且同域名），但打算支持后端依然可访问静态资源（nginx配置仅一份）。搜索nginx配置大部分都通过url前缀进行转发来做前后端分离，不适用目前项目。 说明前端框架：vue 后端框架：thinkphp6 前端部署目录：/www/project_static 后端部署目录：/www/project nginx配置方式api及static转发到php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849server { listen 80; server_name test.aichenk.com; index index.html index.htm index.php; set $static_root '/www/project_static'; set $php_root '/www/project/public'; root $static_root; location ~ \\.php$ { root $php_root; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; fastcgi_buffer_size 128k; fastcgi_buffers 32 32k; } location / { try_files $uri $uri/ /index.html; } location ^~ /api/ { root $php_root; if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } location ^~ /static/ { root $php_root; access_log off; } # 禁用缓存 location = /index.html { add_header Cache-Control no-cache; add_header Pragma no-cache; add_header Expires 0; } location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ { expires max; log_not_found off; access_log off; }} 另外可通过反向代理方式，若第一次判断文件不存在，则发送到另一个服务中，服务中仅关注后端配置。","link":"/2020/06/2020/%E5%90%8C%E5%9F%9F%E5%90%8D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AEnginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/"},{"title":"nginx vue前后端分离配置示例","text":"vue + thinkphp vue为history路由模式，固定/api，/static前缀为php使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253server { listen 80; server_name localhost; set $static_root ''; # web目录 set $php_root ''; # php目录 root $static_root; index index.html index.htm index.php; location ~ \\.php$ { root $php_root; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; fastcgi_buffer_size 128k; fastcgi_buffers 32 32k; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; } location / { try_files $uri $uri/ /index.html; } location ^~ /api/ { root $php_root; if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } location ^~ /static/ { root $php_root; access_log off; } # 首页不缓存 location = /index.html { add_header Cache-Control no-cache; add_header Pragma no-cache; add_header Expires 0; } location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ { expires 12h; log_not_found off; access_log off; }} vue + 端口转发 二级目录可使用此方法 1234567891011121314151617181920212223242526272829303132server { listen 80; server_name localhost; root ''; index index.html index.htm; location ^~ /api/ { proxy_set_header HOST $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://localhost:8080; # proxy_pass http://localhost:8080/; #转发时想去除/api前缀可使用这条 } location / { try_files $uri $uri/ /index.html; } # 首页不缓存 location = /index.html { add_header Cache-Control no-cache; add_header Pragma no-cache; add_header Expires 0; } location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ { expires 12h; log_not_found off; access_log off; }}","link":"/2022/03/2022/nginx%E5%B8%B8%E7%94%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/"},{"title":"webhook触发jenkins进行sonar检测","text":"目的jenkins仅需创建一个job，git推送后自动进行sonar代码检测并上传到sonarqube jenkins插件 已按社区推荐安装基本插件 Generic Webhook Trigger SonarQube Scanner 准备工作 sonar生成令牌 登录后右上角点击”头像 &gt; 我的账号 &gt; 安全“ 生成令牌并复制保存 将令牌添加到jenkins凭证中 “系统管理 &gt; 管理凭证 &gt; 添加凭证” 类型选择Secret text 令牌粘贴到Secret框中，ID及描述可自行设置成想要的 jenkins添加SonarQube Server “系统管理 &gt; 系统配置 &gt; SonarQube servers” 定义name及sonarqube地址，选中刚创建的凭证，点击保存（这里name我命名‘SonarQube’） jenkins添加Sonar Scanner “系统管理 &gt; 全局工具配置 &gt; SonarQube Scanner” 定义name，勾选自动安装，版本选最新即可，点击保存 创建jenkins job 新建job，选择流水线 “构建触发器”选中”Generic Webhook Trigger” 复制http://JENKINS_URL/generic-webhook-trigger/invoke备用，作为触发地址（JENKINS_URL需替换成自己的jenkins地址） Post content parameters提取需要用的参数 github如下 variable expression expressionType defaultValue regexpFilter project_name $.repository.name JSONPath ssh_url $.repository.ssh_url JSONPath ref $.ref JSONPath gitlab如下 variable expression expressionType defaultValue regexpFilter project_name $.project.name JSONPath ssh_url $.project.git_ssh_url JSONPath ref $.ref JSONPath 定义Token，不同token可触发不同job（若token相同则触发多个job） 定义流水线 123456789101112131415161718192021222324252627282930313233pipeline { agent any stages { stage('Check Out!') { steps { script { //解析分支 arr = &quot;${env.ref}&quot;.split(&quot;refs/heads/&quot;) as List currentBranch = arr[1] } git branch: currentBranch, credentialsId: '343aa12a-92a3-4797-a9ea-a8facb4db380', url: '${ssh_url}' //credentialsId为ssh私钥，用于拉git代码 } } stage('Sonar Scan!') { steps { script { sonarqubeScannerHome = tool name: 'SonarQube Scanner' //准备工作第4步的name withSonarQubeEnv('SonarQube') { //准备工作第3步的name，只有一个时可省略 sh &quot;&quot;&quot; ${sonarqubeScannerHome}/bin/sonar-scanner \\ -Dsonar.projectKey=${project_name} \\ -Dsonar.projectName=${project_name} \\ -Dsonar.sources=./ &quot;&quot;&quot; } } } } }} 定义webhook（github为例） 打开项目”Settings &gt; Webhooks” 写入url及创建job第二步的token（注意token在url后） 验证 触发push事件后，可看到jenkins开始构建，完成后sonarqube平台也可看到相关报告","link":"/2022/02/2022/webhook%E8%A7%A6%E5%8F%91jenkins%E8%BF%9B%E8%A1%8Csonar%E6%A3%80%E6%B5%8B/"},{"title":"阿里云logtail采集容器内日志到sls导致容器内存增加","text":"现象nginx容器接入logtail后，因为服务请求量较大导致日志量快速增加，很快就触发了内存告警，甚至触发容器伸缩查看内存使用如图所示(单位：GB，统计参数：container_memory_working_set_bytes) 排查过程略去一大波nginx参数配置的苦逼历程...最终排查后发现nginx使用内存并不多，而大部分内存是被pagecache占用。因为logtail会读文件，文件会占用pagecache，这时候系统释放是比较慵懒的，所以pagecache越用越多，这部分内存随时都可以释放，但是在容器里，这是不合理的 随后进行了一些操作测试对内存占用的影响 清理容器内日志 宿主机上清理pagecache 内存清理情况如下图 解决虽然在宿主机增加定时脚本清理pagecache最省力，但是影响范围过大，不是很合理。最终采用容器内增加定时清理日志脚本解决，效果如下图","link":"/2022/08/2022/%E9%98%BF%E9%87%8C%E4%BA%91logtail%E9%87%87%E9%9B%86%E5%AE%B9%E5%99%A8%E5%86%85%E6%97%A5%E5%BF%97%E5%88%B0sls%E5%AF%BC%E8%87%B4%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E5%A2%9E%E5%8A%A0/"}],"tags":[{"name":"sonar","slug":"sonar","link":"/tags/sonar/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"composer","slug":"composer","link":"/tags/composer/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"swoole","slug":"swoole","link":"/tags/swoole/"},{"name":"brew","slug":"brew","link":"/tags/brew/"},{"name":"oss","slug":"oss","link":"/tags/oss/"},{"name":"sdk","slug":"sdk","link":"/tags/sdk/"},{"name":"thinkphp","slug":"thinkphp","link":"/tags/thinkphp/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"cron","slug":"cron","link":"/tags/cron/"},{"name":"rabbitmq","slug":"rabbitmq","link":"/tags/rabbitmq/"},{"name":"sls","slug":"sls","link":"/tags/sls/"},{"name":"logtail","slug":"logtail","link":"/tags/logtail/"},{"name":"阿里云","slug":"阿里云","link":"/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}],"categories":[{"name":"2019","slug":"2019","link":"/categories/2019/"},{"name":"2021","slug":"2021","link":"/categories/2021/"},{"name":"2022","slug":"2022","link":"/categories/2022/"},{"name":"2020","slug":"2020","link":"/categories/2020/"}]}